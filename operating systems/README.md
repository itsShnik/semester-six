# Operating Systems

- [Website of the course](http://www.facweb.iitkgp.ac.in/~isg/OS/index.html)

## Content of the course

1. Introduction
2. Processes
3. CPU Scheduling
4. Multithreading
5. Process Synchronization

Why do we need to learn these in this particular order? What we aim to learn through this course is what, how and why of the operating systems. The most important thing an operating system does is manage a process. (Almost everything that's going in the computer can be categorised as a proces) which is why we need to learn the basics of a process. Next, we need to know how does a CPU communicates with the operating system to manage a process, an important part of which is scheduling the process itself. Then we need to know that there is something other than process that is also an important component of the operating system, thread. Then we move into the subtleties of processes and threads and how can a cpu implement many processes concurrently with the help of the operating systems. So, let's start right ahead.

## Notes

### 1. Introuduction

__What is an OS?__: An operating system provides an interface to the user applications to interact with the hardware. OS manages the resources and services allocated to an application program and also controls all the processes / jobs to be executed. We shall elaborate on what a process and a job is later on.

__Structure of the OS__: By structure we refer to the control flow in an operating system. How does the os work as an intermediary between the applciations and the hardware? Take this for example, you are running an applcation that requires you to take the input from the keyboard, this service is provided by the os, os informs the device controller to take the input and then it transfers the input wherever needed.

![structure](../images/os/structure.png?raw=true)

__Kernel__: The kernel is the part of the operating system closest to the hardware, it is the set of functions that provide essential functionalities of the operating system, much like what a heart does to the human.

A kernel is one of the first programs loaded on startup (after the bootloader). It handles the rest of the startup as well as the input/output requests from the software, translating them into data processing instructions to be executed by the cpu. It is loaded in a protected space in the memory that the applications can't mess with. It handles the peripherals like the keyboard, mouse and speakers.

The applications (user programs) might want to interact with the kernel requesting for the input. How does that happen? How do the applications and other os programs like shell interact with the kernel? One of the methods is __interrupt__.

__Interrupt__: We can think of the interrupt as a wake up call to the kernel, when interrupt comes, some functionalities of the kernel is invoked. It is a _signal_ generated by a software/hardware, yet we will learn that signals are a little different from interrupts. Kernel is interrupt driven and doesn't need to run all the time (it just needs to _listen_ all the time). 

An interrupt can be generated by the software or the hardware (the device controllers). 

![interrupts](../images/os/interrupts.png?raw=true)

Let's look at how does the following c program processes I/O and interacts with the kernel with the help of the CPU.

```c
#include<stdlib.h>
#include<stdio.h>

int main(){
	int n;
	scanf("%d", &n);
	printf("You entered: %d\n", n);
	return 0;
}
```

First of all the code is compiled and converted into assembly and then into the byte code which works as a list of instructions to be executed by the CPU. (skipping the part till declaring the variable n) As soon as the instrcution about scanf is processed in the CPU, the CPU uses a system call (write) (for now think of the system call as an interrupt) to invoke the kernel functionality related to the function scanf, kernel has a predefined reaction to this interrupt (mentioned in its Instruction Service Routine, ISR) and it kind of asks the device controller for keyboard (USB device controller) to get ready to take the input. As soon as you press a key, the device controller _interrupts_ the kernel and the kernel handles the interrupt related to _pressing a key_ and _signals_ the CPU to do the necessary. Similar is the event _lifting the key_ and it is processed similarily. After the complete input is taken (till you hit the enter key) the CPU executes the instruction related to printf. Printf all uses an interrupt (system call actually, write) to print the output on the screen of your monitor.

This is an oversimplified view of what this program does since we have ingnored all the complexities related to other device controllers, process handling and what not.
